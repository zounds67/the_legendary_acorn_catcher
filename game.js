// Generated by CoffeeScript 2.7.0
(function() {
  // Totoro's Acorn Catch Game

  // Welcome! In this game, you help Totoro catch falling acorns!
  // Your job is to fill in the functions below to make the game work.
  // Look for "YOUR CODE HERE" to find where to write your code.

  // Good luck and have fun!

  // ============================================================
  // LootLocker Leaderboard Class - Simple API wrapper
  // ============================================================
  var Game, LootLocker;

  LootLocker = class LootLocker {
    constructor(apiKey, leaderboardKey, apiDomain) {
      this.apiKey = apiKey;
      this.leaderboardKey = leaderboardKey;
      this.apiDomain = apiDomain;
      this.sessionToken = null;
    }

    init() {
      return fetch(`${this.apiDomain}/game/v2/session/guest`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          game_key: this.apiKey,
          game_version: "1.0.0"
        })
      }).then(function(response) {
        return response.json();
      }).then((data) => {
        if (data.session_token) {
          this.sessionToken = data.session_token;
        } else {
          throw new Error(data.message || "No session token received");
        }
        return data;
      });
    }

    setName(name) {
      return fetch(`${this.apiDomain}/game/player/name`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          "x-session-token": this.sessionToken
        },
        body: JSON.stringify({
          name: name
        })
      });
    }

    submitScore(score) {
      return fetch(`${this.apiDomain}/game/leaderboards/${this.leaderboardKey}/submit`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-session-token": this.sessionToken
        },
        body: JSON.stringify({
          score: score
        })
      }).then(function(response) {
        return response.json();
      });
    }

    getScores() {
      return fetch(`${this.apiDomain}/game/leaderboards/${this.leaderboardKey}/list?count=10`, {
        method: "GET",
        headers: {
          "x-session-token": this.sessionToken
        }
      }).then(function(response) {
        return response.json();
      }).then(function(data) {
        return data.items || [];
      });
    }

  };

  Game = class Game {
    constructor() {
      var ref;
      this.gameLoop = this.gameLoop.bind(this);
      this.canvas = document.getElementById('game-canvas');
      this.ctx = this.canvas.getContext('2d');
      this.scoreElement = document.getElementById('score');
      this.livesElement = document.getElementById('lives');
      this.powerupDisplay = document.getElementById('powerup-display');
      this.gameOverElement = document.getElementById('game-over');
      this.finalScoreElement = document.getElementById('final-score');
      this.restartBtn = document.getElementById('restart-btn');
      // LootLocker setup
      this.lootlocker = new LootLocker('dev_d454f8a490d943d9acaa1b88507f9e08', 'acorncatcher', 'https://tgb2om7o.api.lootlocker.io');
      this.playerName = localStorage.getItem('playerName') || '';
      this.registeredName = this.playerName; // The name they've already submitted scores with
      
      // Leaderboard UI elements
      this.leaderboardList = document.getElementById('leaderboard-list');
      this.nameInput = document.getElementById('player-name-input');
      this.submitScoreBtn = document.getElementById('submit-score-btn');
      this.leaderboardStatus = document.getElementById('leaderboard-status');
      this.init();
      this.setupControls();
      this.restartBtn.addEventListener('click', () => {
        return this.restart();
      });
      if ((ref = this.submitScoreBtn) != null) {
        ref.addEventListener('click', () => {
          return this.handleSubmitScore();
        });
      }
      // Initialize LootLocker session
      this.initLeaderboard();
    }

    init() {
      this.score = 0;
      this.lives = 3;
      this.gameOver = false;
      this.fallingObjects = [];
      this.spawnTimer = 0;
      this.spawnInterval = 60; // frames between spawns
      this.difficulty = 1;
      this.difficultyTimer = 0;
      // Totoro player - this is our character!
      // x and y are the position on the screen
      // width and height are how big Totoro is
      // speed is how fast Totoro moves
      this.totoro = {
        x: this.canvas.width / 2 - 40,
        y: this.canvas.height - 80,
        width: 80,
        height: 70,
        speed: 6,
        baseSpeed: 6,
        powered: false,
        powerTimer: 0
      };
      // These track which arrow keys are being pressed
      this.keys = {
        left: false,
        right: false
      };
      this.updateDisplay();
      return this.gameOverElement.classList.add('hidden');
    }

    setupControls() {
      document.addEventListener('keydown', (e) => {
        if (this.gameOver) {
          return;
        }
        switch (e.key) {
          case 'ArrowLeft':
          case 'a':
            this.keys.left = true;
            return e.preventDefault();
          case 'ArrowRight':
          case 'd':
            this.keys.right = true;
            return e.preventDefault();
        }
      });
      return document.addEventListener('keyup', (e) => {
        switch (e.key) {
          case 'ArrowLeft':
          case 'a':
            return this.keys.left = false;
          case 'ArrowRight':
          case 'd':
            return this.keys.right = false;
        }
      });
    }

    // ============================================================
    // FUNCTION 1: Move Totoro
    // ============================================================
    // This function moves Totoro left or right when you press keys.

    // HOW IT WORKS:
    // - @keys.left is true when the left arrow is pressed
    // - @keys.right is true when the right arrow is pressed
    // - @totoro.x is Totoro's position (small number = left side, big number = right side)
    // - @totoro.speed is how many pixels to move (it equals 6)

    // WHAT TO DO:
    // - If left key is pressed, subtract speed from x position
    // - If right key is pressed, add speed to x position

    // EXAMPLE:
    //   To move something left, you subtract: x = x - speed
    //   To move something right, you add: x = x + speed
    // ============================================================
    moveTotoro() {
      // YOUR CODE HERE
      // Hint: Use "if @keys.left" to check if left is pressed
      // Hint: Use @totoro.x to change position
      // Hint: Use @totoro.speed for how much to move
      if (this.keys.left) {
        this.totoro.x = this.totoro.x - this.totoro.speed;
      }
      if (this.keys.right) {
        return this.totoro.x = this.totoro.x + this.totoro.speed;
      }
    }

    
      // ============================================================
    // FUNCTION 2: Keep Totoro On Screen
    // ============================================================
    // This function stops Totoro from walking off the screen!

    // HOW IT WORKS:
    // - @totoro.x is where Totoro is (left-right position)
    // - @canvas.width is how wide the screen is (400 pixels)
    // - @totoro.width is how wide Totoro is (80 pixels)
    // - The left edge of the screen is 0
    // - The right edge is @canvas.width - @totoro.width

    // WHAT TO DO:
    // - If Totoro goes too far left (x < 0), set x to 0
    // - If Totoro goes too far right, set x to the right edge

    // EXAMPLE:
    //   if @totoro.x < 0
    //     @totoro.x = 0
    // ============================================================
    keepTotoroOnScreen() {
      // YOUR CODE HERE
      // Hint: Check if @totoro.x is less than 0 (too far left)
      // Hint: Check if @totoro.x is greater than @canvas.width - @totoro.width (too far right)
      if (this.totoro.x < 0) {
        this.totoro.x = 0;
      }
      if (this.totoro.x > this.canvas.width - this.totoro.width) {
        return this.totoro.x = this.canvas.width - this.totoro.width;
      }
    }

    // ============================================================
    // FUNCTION 3: Move Falling Objects Down
    // ============================================================
    // This function makes all the objects fall down the screen!

    // HOW IT WORKS:
    // - @fallingObjects is a list of all things falling (acorns, dust mites, etc)
    // - Each object has a y position (small = top of screen, big = bottom)
    // - Each object has a speed (how fast it falls)

    // WHAT TO DO:
    // - Go through each object in the list
    // - Add the speed to the y position to make it fall down

    // EXAMPLE:
    //   for obj in @fallingObjects
    //     # do something with obj
    // ============================================================
    moveFallingObjects() {
      var j, len, obj, ref, results;
      ref = this.fallingObjects;
      // YOUR CODE HEREfor
      // Hint: Use "for obj in @fallingObjects" to loop through objects
      // Hint: Add obj.speed to obj.y to make it fall down
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        obj = ref[j];
        results.push(obj.y = obj.y + obj.speed);
      }
      return results;
    }

    // ============================================================
    // FUNCTION 4: Check If Two Things Touch (Collision)
    // ============================================================
    // This function checks if Totoro is touching a falling object.
    // Returns true if they touch, false if they don't.

    // HOW IT WORKS:
    // - 'a' is one object (like Totoro)
    // - 'b' is another object (like an acorn)
    // - Each object has: x, y, width, height
    // - Two rectangles touch if they overlap

    // SIMPLE VERSION (just check x and y):
    // - Objects are close if their x positions are close
    // - AND their y positions are close

    // WHAT TO DO (easy version):
    // - Check if the distance between them is small enough
    // - Return true if they're close, false if they're far

    // HINT: You can check if 'a' overlaps 'b' like this:
    //   - a's right side (a.x + a.width) is past b's left side (b.x)
    //   - AND a's left side (a.x) is before b's right side (b.x + b.width)
    //   - AND same idea for top/bottom with y and height
    // ============================================================
    collides(a, b) {
      // YOUR CODE HERE
      // Easy version - just check if they're close:
      //   Check if a.x is close to b.x (within 40 pixels)
      //   AND a.y is close to b.y (within 40 pixels)

      //if a.x - b.x < 10 and a.y - b.y < 10
      //return true
      // Harder version - check if rectangles overlap:
      //   a.x < b.x + b.width and
      //   a.x + a.width > b.x and
      //   a.y < b.y + b.height and
      //   a.y + a.height > b.y
      if (a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y) {
        return true;
      } else {
        return false;
      }
    }

    // ============================================================
    // FUNCTION 5: Handle What Happens When Totoro Catches Things
    // ============================================================
    // This function decides what happens when Totoro touches something!

    // OBJECT TYPES:
    // - 'acorn' = Good! Add 10 points to score
    // - 'dustmite' = Bad! Lose 1 life
    // - 'catbus' = Power-up! Makes Totoro faster

    // HOW IT WORKS:
    // - obj.type tells you what kind of object it is
    // - @score is the player's score
    // - @lives is how many lives left
    // - @updateDisplay() refreshes the score on screen

    // WHAT TO DO:
    // - If it's an acorn: add 10 to @score
    // - If it's a dustmite: subtract 1 from @lives
    // - Call @updateDisplay() after changing score or lives
    // - If lives reach 0, call @endGame()
    // ============================================================
    handleCatch(obj) {
      // YOUR CODE HERE
      // Hint: Use "if obj.type is 'acorn'" to check object type
      // Hint: @score += 10 adds 10 to the score
      // Hint: @lives -= 1 subtracts 1 from lives
      // Hint: Call @updateDisplay() to show the new score
      // Hint: Check if @lives <= 0 and call @endGame() if true
      //@totoro =
      //  x: @canvas.width / 2 - 40
      //  y: @canvas.height - 80
      //  width: 80
      //  height: 70
      //  speed: 6
      //  baseSpeed: 6
      //  powered: false
      //  powerTimer: 0
      if (obj.type === 'acorn') {
        this.score = this.score + 10;
      }
      if (obj.type === 'dustmite') {
        this.lives = this.lives - 1;
      }
      if (obj.type === 'catbus') {
        this.totoro.powered = true;
        this.totoro.speed = this.totoro.speed * 2;
        this.totoro.powerTimer = 1000;
        this.powerupDisplay.textContent = 'Cat Bus Speed!';
      }
      this.updateDisplay();
      if (this.lives === 0) {
        return this.endGame();
      }
    }

    // ============================================================
    // FUNCTION 6: Remove Objects That Fall Off Screen
    // ============================================================
    // This function removes objects that fell past the bottom!

    // HOW IT WORKS:
    // - Objects that go past y = 450 are off the screen
    // - We need to keep only objects that are still visible
    // - We use filter to keep objects where y < 450

    // WHAT TO DO:
    // - Use filter to keep only objects with y less than 450

    // EXAMPLE:
    //   To filter a list and keep only some items:
    //   @myList = @myList.filter (item) -> item.value < 100
    // ============================================================
    removeOffScreenObjects() {
      var j, len, obj, ref, rembutt;
      // YOUR CODE HERE
      // Hint: @fallingObjects = @fallingObjects.filter (obj) -> ???
      // Hint: Keep objects where obj.y < 450
      // Alternative Hint:  Use a for loop!
      // Create a new array: remObjects = []
      // for obj in @fallingobjects
      //   do something (add obj to remObjects ush remObjects.push obj)
      //   the key is to know which objects to keep
      //   Keep objects where obj.y < 450
      rembutt = [];
      ref = this.fallingObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        obj = ref[j];
        if (obj.y < 450) {
          rembutt.push(obj);
        }
      }
      return this.fallingObjects = rembutt;
    }

    // ============================================================
    // This spawns new falling objects - already done for you!
    // ============================================================
    spawnObject() {
      var rand, x;
      rand = Math.random();
      x = Math.random() * (this.canvas.width - 30);
      if (rand < 0.6) { // 60% acorns
        return this.fallingObjects.push({
          type: 'acorn',
          x: x,
          y: -30,
          width: 25,
          height: 30,
          speed: 2 + this.difficulty * 0.5
        });
      } else if (rand < 0.95) { // 35% dust mites
        return this.fallingObjects.push({
          type: 'dustmite',
          x: x,
          y: -25,
          width: 30,
          height: 25,
          speed: 2.5 + this.difficulty * 0.3,
          wobble: 0 // 5% cat bus power-up
        });
      } else {
        return this.fallingObjects.push({
          type: 'catbus',
          x: x,
          y: -35,
          width: 50,
          height: 30,
          speed: 3
        });
      }
    }

    // ============================================================
    // Main update function - calls all your functions!
    // ============================================================
    update() {
      var j, len, obj, ref;
      if (this.gameOver) {
        return;
      }
      // Call the functions YOU wrote!
      this.moveTotoro();
      this.keepTotoroOnScreen();
      // Handle power-up timer (done for you)
      if (this.totoro.powered) {
        this.totoro.powerTimer--;
        if (this.totoro.powerTimer <= 0) {
          this.totoro.powered = false;
          this.totoro.speed = this.totoro.baseSpeed;
          this.powerupDisplay.textContent = '';
        }
      }
      // Spawn new objects (done for you)
      this.spawnTimer++;
      if (this.spawnTimer >= this.spawnInterval) {
        this.spawnObject();
        this.spawnTimer = 0;
      }
      // Increase difficulty over time (done for you)
      this.difficultyTimer++;
      if (this.difficultyTimer >= 200) {
        this.difficulty += 0.2;
        this.spawnInterval = Math.max(4, this.spawnInterval - 3);
        this.difficultyTimer = 0;
      }
      // Call YOUR function to move objects down!
      this.moveFallingObjects();
      ref = this.fallingObjects;
      // Add wobble to dust mites (done for you)
      for (j = 0, len = ref.length; j < len; j++) {
        obj = ref[j];
        if (obj.type === 'dustmite') {
          obj.wobble += 0.1;
          obj.x += Math.sin(obj.wobble) * 1.5;
        }
      }
      // Check collisions using YOUR functions!
      this.checkCollisions();
      // Call YOUR function to remove off-screen objects!
      return this.removeOffScreenObjects();
    }

    checkCollisions() {
      var i, j, k, len, len1, obj, ref, ref1, results, toRemove;
      toRemove = [];
      ref = this.fallingObjects;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        obj = ref[i];
        // Use YOUR collides function!
        if (this.collides(this.totoro, obj)) {
          toRemove.push(i);
          // Use YOUR handleCatch function!
          this.handleCatch(obj);
        }
      }
      ref1 = toRemove.reverse();
      // Remove collected objects
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        i = ref1[k];
        results.push(this.fallingObjects.splice(i, 1));
      }
      return results;
    }

    updateDisplay() {
      this.scoreElement.textContent = this.score;
      return this.livesElement.textContent = this.lives;
    }

    endGame() {
      this.gameOver = true;
      this.finalScoreElement.textContent = this.score;
      this.gameOverElement.classList.remove('hidden');
      this.powerupDisplay.textContent = '';
      // Show leaderboard UI and enable submission
      this.submitScoreBtn.disabled = false;
      this.submitScoreBtn.style.display = 'inline-block';
      this.nameInput.disabled = false;
      this.nameInput.value = this.playerName;
      this.leaderboardStatus.textContent = '';
      // Refresh leaderboard display
      return this.refreshLeaderboard();
    }

    restart() {
      this.init();
      return this.gameLoop();
    }

    // ============================================================
    // LootLocker Leaderboard Methods (Simplified)
    // ============================================================
    initLeaderboard() {
      return this.lootlocker.init().then(() => {
        return this.refreshLeaderboard();
      }).catch(() => {
        return this.leaderboardList.innerHTML = '<li class="error">Could not connect to leaderboard</li>';
      });
    }

    handleSubmitScore() {
      var nameChanged, playerName, startFresh;
      if (!this.lootlocker.sessionToken) {
        return;
      }
      playerName = this.nameInput.value.trim() || 'Anonymous';
      this.submitScoreBtn.disabled = true;
      this.leaderboardStatus.textContent = 'Submitting score...';
      // If player changed their name, start a new session (creates new leaderboard entry)
      nameChanged = this.registeredName && playerName !== this.registeredName;
      startFresh = nameChanged ? this.lootlocker.init() : Promise.resolve();
      return startFresh.then(() => {
        return this.lootlocker.setName(playerName);
      }).then(() => {
        return this.lootlocker.submitScore(this.score);
      }).then((result) => {
        // Save the name as their registered name for future submissions
        this.registeredName = playerName;
        this.playerName = playerName;
        localStorage.setItem('playerName', playerName);
        this.leaderboardStatus.textContent = `Score submitted! Rank: #${result.rank}`;
        this.submitScoreBtn.style.display = 'none';
        this.nameInput.disabled = true;
        return this.refreshLeaderboard();
      }).catch(() => {
        this.leaderboardStatus.textContent = 'Failed to submit score';
        return this.submitScoreBtn.disabled = false;
      });
    }

    refreshLeaderboard() {
      if (!this.lootlocker.sessionToken) {
        return;
      }
      return this.lootlocker.getScores().then((entries) => {
        return this.displayLeaderboard(entries);
      }).catch(() => {
        return this.leaderboardList.innerHTML = '<li class="error">Could not load leaderboard</li>';
      });
    }

    // ============================================================
    // FUNCTION 7: Show the Leaderboard
    // ============================================================
    // This function shows the top scores on the leaderboard!

    // HOW IT WORKS:
    // - 'entries' is a list of score entries from other players
    // - Each entry has:
    //     entry.rank = their position (1 = first place, 2 = second, etc)
    //     entry.player.name = the player's name
    //     entry.score = how many points they got
    // - @addToLeaderboard(rank, name, score) adds one line to the leaderboard

    // WHAT TO DO:
    // - Go through each entry in the list
    // - Get the rank, name, and score from each entry
    // - Call @addToLeaderboard to display it

    // EXAMPLE:
    //   for entry in entries
    //     rank = entry.rank
    //     name = entry.player.name
    //     # now call @addToLeaderboard with rank, name, and score
    // ============================================================
    displayLeaderboard(entries) {
      var e, j, len, pn, rank, results, score;
      this.leaderboardList.innerHTML = '';
      if (entries.length === 0) {
        this.leaderboardList.innerHTML = '<li class="no-scores">No scores yet. Be the first!</li>';
        return;
      }
// YOUR CODE HERE
// Hint: Use "for entry in entries" to loop through all the scores
// Hint: Get the rank with entry.rank
// Hint: Get the name with entry.player.name
// Hint: Get the score with entry.score
// Hint: Call @addToLeaderboard(rank, name, score) to show each one
      results = [];
      for (j = 0, len = entries.length; j < len; j++) {
        e = entries[j];
        rank = e.rank;
        pn = e.player.name;
        score = e.score;
        results.push(this.addToLeaderboard(rank, pn, score));
      }
      return results;
    }

    // This helper function adds one entry to the leaderboard display
    // (You don't need to change this - just call it from above!)
    addToLeaderboard(rank, name, score) {
      var li, nameSpan, rankSpan, scoreSpan;
      li = document.createElement('li');
      li.className = 'leaderboard-entry';
      rankSpan = document.createElement('span');
      rankSpan.className = 'rank';
      rankSpan.textContent = `#${rank}`;
      nameSpan = document.createElement('span');
      nameSpan.className = 'player-name';
      nameSpan.textContent = name || 'Anonymous';
      scoreSpan = document.createElement('span');
      scoreSpan.className = 'player-score';
      scoreSpan.textContent = score;
      li.appendChild(rankSpan);
      li.appendChild(nameSpan);
      li.appendChild(scoreSpan);
      return this.leaderboardList.appendChild(li);
    }

    // ============================================================
    // All the drawing code below - you don't need to change this!
    // ============================================================
    draw() {
      var j, len, obj, ref, results;
      // Clear canvas
      this.ctx.fillStyle = '#87CEEB';
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      // Draw grass at bottom
      this.ctx.fillStyle = '#228B22';
      this.ctx.fillRect(0, this.canvas.height - 20, this.canvas.width, 20);
      // Draw Totoro
      this.drawTotoro();
      ref = this.fallingObjects;
      // Draw falling objects
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        obj = ref[j];
        switch (obj.type) {
          case 'acorn':
            results.push(this.drawAcorn(obj));
            break;
          case 'dustmite':
            results.push(this.drawDustMite(obj));
            break;
          case 'catbus':
            results.push(this.drawCatBus(obj));
            break;
          default:
            results.push(void 0);
        }
      }
      return results;
    }

    drawTotoro() {
      var i, j, k, len, ref, results, x, y;
      x = this.totoro.x;
      y = this.totoro.y;
      // Body - gray oval
      this.ctx.fillStyle = this.totoro.powered ? '#DAA520' : '#696969';
      this.ctx.beginPath();
      this.ctx.ellipse(x + 40, y + 40, 38, 35, 0, 0, Math.PI * 2);
      this.ctx.fill();
      // Belly - lighter gray
      this.ctx.fillStyle = '#D3D3D3';
      this.ctx.beginPath();
      this.ctx.ellipse(x + 40, y + 45, 25, 22, 0, 0, Math.PI * 2);
      this.ctx.fill();
      // Belly markings
      this.ctx.fillStyle = '#808080';
      for (i = j = 0; j <= 5; i = ++j) {
        this.ctx.beginPath();
        this.ctx.ellipse(x + 25 + i * 6, y + 45, 2, 4, 0, 0, Math.PI * 2);
        this.ctx.fill();
      }
      // Ears
      this.ctx.fillStyle = this.totoro.powered ? '#DAA520' : '#696969';
      this.ctx.beginPath();
      this.ctx.moveTo(x + 15, y + 10);
      this.ctx.lineTo(x + 25, y - 5);
      this.ctx.lineTo(x + 30, y + 15);
      this.ctx.fill();
      this.ctx.beginPath();
      this.ctx.moveTo(x + 50, y + 15);
      this.ctx.lineTo(x + 55, y - 5);
      this.ctx.lineTo(x + 65, y + 10);
      this.ctx.fill();
      // Eyes
      this.ctx.fillStyle = 'white';
      this.ctx.beginPath();
      this.ctx.arc(x + 30, y + 25, 8, 0, Math.PI * 2);
      this.ctx.arc(x + 50, y + 25, 8, 0, Math.PI * 2);
      this.ctx.fill();
      // Pupils
      this.ctx.fillStyle = 'black';
      this.ctx.beginPath();
      this.ctx.arc(x + 30, y + 25, 4, 0, Math.PI * 2);
      this.ctx.arc(x + 50, y + 25, 4, 0, Math.PI * 2);
      this.ctx.fill();
      // Nose
      this.ctx.fillStyle = '#2F2F2F';
      this.ctx.beginPath();
      this.ctx.ellipse(x + 40, y + 32, 5, 3, 0, 0, Math.PI * 2);
      this.ctx.fill();
      // Whiskers
      this.ctx.strokeStyle = '#2F2F2F';
      this.ctx.lineWidth = 1;
      ref = [-1, 0, 1];
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        i = ref[k];
        this.ctx.beginPath();
        this.ctx.moveTo(x + 15, y + 35 + i * 4);
        this.ctx.lineTo(x + 5, y + 33 + i * 6);
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(x + 65, y + 35 + i * 4);
        this.ctx.lineTo(x + 75, y + 33 + i * 6);
        results.push(this.ctx.stroke());
      }
      return results;
    }

    drawAcorn(obj) {
      var i, j, x, y;
      x = obj.x;
      y = obj.y;
      // Acorn cap
      this.ctx.fillStyle = '#8B4513';
      this.ctx.beginPath();
      this.ctx.ellipse(x + 12, y + 8, 12, 8, 0, 0, Math.PI * 2);
      this.ctx.fill();
      // Cap pattern
      this.ctx.strokeStyle = '#654321';
      this.ctx.lineWidth = 1;
      for (i = j = 0; j <= 4; i = ++j) {
        this.ctx.beginPath();
        this.ctx.arc(x + 12, y + 4, 3 + i * 2, 0, Math.PI);
        this.ctx.stroke();
      }
      // Stem
      this.ctx.fillStyle = '#654321';
      this.ctx.fillRect(x + 10, y - 2, 4, 6);
      // Acorn body
      this.ctx.fillStyle = '#DEB887';
      this.ctx.beginPath();
      this.ctx.ellipse(x + 12, y + 20, 10, 12, 0, 0, Math.PI * 2);
      return this.ctx.fill();
    }

    drawDustMite(obj) {
      var angle, i, j, x, y;
      x = obj.x;
      y = obj.y;
      // Fuzzy body
      this.ctx.fillStyle = '#1a1a1a';
      this.ctx.beginPath();
      this.ctx.arc(x + 15, y + 12, 12, 0, Math.PI * 2);
      this.ctx.fill();
      // Fuzzy edges
      this.ctx.fillStyle = '#333333';
      for (i = j = 0; j <= 7; i = ++j) {
        angle = (i / 8) * Math.PI * 2;
        this.ctx.beginPath();
        this.ctx.arc(x + 15 + Math.cos(angle) * 10, y + 12 + Math.sin(angle) * 10, 4, 0, Math.PI * 2);
        this.ctx.fill();
      }
      // Eyes
      this.ctx.fillStyle = 'white';
      this.ctx.beginPath();
      this.ctx.arc(x + 11, y + 10, 4, 0, Math.PI * 2);
      this.ctx.arc(x + 19, y + 10, 4, 0, Math.PI * 2);
      this.ctx.fill();
      // Pupils
      this.ctx.fillStyle = 'black';
      this.ctx.beginPath();
      this.ctx.arc(x + 11, y + 10, 2, 0, Math.PI * 2);
      this.ctx.arc(x + 19, y + 10, 2, 0, Math.PI * 2);
      return this.ctx.fill();
    }

    drawCatBus(obj) {
      var i, j, k, x, y;
      x = obj.x;
      y = obj.y;
      // Body
      this.ctx.fillStyle = '#DAA520';
      this.ctx.beginPath();
      this.ctx.roundRect(x, y + 5, 50, 20, 8);
      this.ctx.fill();
      // Stripes
      this.ctx.fillStyle = '#B8860B';
      for (i = j = 0; j <= 3; i = ++j) {
        this.ctx.fillRect(x + 8 + i * 10, y + 8, 4, 14);
      }
      // Face area
      this.ctx.fillStyle = '#DAA520';
      this.ctx.beginPath();
      this.ctx.arc(x + 45, y + 15, 10, 0, Math.PI * 2);
      this.ctx.fill();
      // Eyes
      this.ctx.fillStyle = '#FFFF00';
      this.ctx.beginPath();
      this.ctx.arc(x + 43, y + 12, 4, 0, Math.PI * 2);
      this.ctx.arc(x + 50, y + 12, 4, 0, Math.PI * 2);
      this.ctx.fill();
      // Pupils
      this.ctx.fillStyle = 'black';
      this.ctx.beginPath();
      this.ctx.arc(x + 43, y + 12, 2, 0, Math.PI * 2);
      this.ctx.arc(x + 50, y + 12, 2, 0, Math.PI * 2);
      this.ctx.fill();
      // Ears
      this.ctx.fillStyle = '#DAA520';
      this.ctx.beginPath();
      this.ctx.moveTo(x + 40, y + 5);
      this.ctx.lineTo(x + 42, y - 3);
      this.ctx.lineTo(x + 46, y + 5);
      this.ctx.fill();
      this.ctx.beginPath();
      this.ctx.moveTo(x + 48, y + 5);
      this.ctx.lineTo(x + 52, y - 3);
      this.ctx.lineTo(x + 54, y + 5);
      this.ctx.fill();
      // Legs
      this.ctx.fillStyle = '#DAA520';
      for (i = k = 0; k <= 3; i = ++k) {
        this.ctx.fillRect(x + 5 + i * 11, y + 22, 5, 6);
      }
      // Smile
      this.ctx.strokeStyle = '#8B4513';
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.arc(x + 46, y + 16, 5, 0.2, Math.PI - 0.2);
      return this.ctx.stroke();
    }

    gameLoop() {
      if (this.gameOver) {
        return;
      }
      this.update();
      this.draw();
      return requestAnimationFrame(this.gameLoop);
    }

    start() {
      return this.gameLoop();
    }

  };

  // Start the game when DOM is ready
  document.addEventListener('DOMContentLoaded', function() {
    var game;
    game = new Game();
    return game.start();
  });

}).call(this);
